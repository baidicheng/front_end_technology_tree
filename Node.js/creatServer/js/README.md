[toc]
### Node.js介绍
---
#### 一、Node.js 简介
##### 1.1 Node.js 是什么？
- Node.js 是一个 JavaScript运行环境，它依依赖于 `Chrome V8` 引擎进行代码解释。
##### 1.2 Node.js 有什么特点？
- Node.js 使用事件驱动，非阻塞I / O模型。
- 轻量、可伸缩，适于实时数据交互应用
- 单进程，单线程
- Node.js的软件包生态系统npm是全球最大的开源库生态系统
##### 1.3 拓展：事件驱动和非阻塞 I/O
###### 1.3.1 什么是事件驱动？
- 事件驱动编程（Evnet-driven programming）是一种编程风格，由事件来决定程序的执行流程，事件由事件处理器（event handler），如点击鼠标或者按钮，或事件回调（event callback），如数据库返回一个查询结果，来处理，事件回调是当某个特定事件发生时被调用的函数，比如数据库返回了查询结果或者用户单击了一个按钮。
###### 1.3.2 为什么要使用事件驱动编程。
首先在传统的堵塞I/O编程模式里，数据库查询可能像下面这样。
```
    // 通过查询数据库返回的结果，再进行另一个进程或线程
    result = query('SELECT * FROM posts WHERE id = 1');
    do_something_with(result); 
```
上面的 query 函数会让当前线程或进程一直处于等待状态，直到底层数据库完成查询操作并返回结果才会执行下一个进程或线程即 do_something_with 函数，这样就会造成 I/O 阻塞。  

下面再事件驱动模型中的查询过程。
```
    /*首先先定义一个函数 query_finished，它包含了完成数据库查询后要做的事，
    然后把这个函数当成参数传递给 query 函数，当 query 函数完成数据库查询操作之后就会调用 query_finished 函数，而不仅仅返回查询结果*/
    query_finished = function(result) {
            do_something_with(result);
    }
    query('SELECT * FROM posts WHERE id = 1', query_finished);
```
当你感兴趣的事件发生时会调用你定义的函数，而不是简单的返回结果值，这种编程模型就叫事件驱动编程或异步编程。这是Node一个最明显的特性，这种编程模型意味着当前进程在执行I/O操作时不会被阻塞，因此，多个I/O操作可以并行执行，当操作完成后相应的回调函数就会被调用。
###### 1.3.3 参考文章
- [Node.js中的事件驱动编程详解](http://www.jb51.net/article/53812.htm)

#### 二、Node.js 作用和优缺点
##### 2.1 采用事件驱动、异步编程解决高并发问题（最重要的作用）
传统的单进程容易产生阻塞，而采用多线程则又会出现新的问题就是容易产生高并发，如 PHP 或者 Java，高并发就会消耗大量的资源，如服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接可能需要20M的内存。这就是为什么一般并发量一大，就需要多开服务器。  
Node.js 如何解决服务器并发连接问题：更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。
##### 2.2 解决I/O阻塞，适用I/o密集型应用
Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。
##### 2.3 Node.js 缺点
- 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃
- 单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。
##### 2.4 针对 Node.js 缺点的解决方案
- Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；
- 开多个进程监听同一个端口，使用cluster模块；
- 开源组件库质量参差不齐，更新快，向下不兼容
- Debug不方便，错误没有stack trace

#### 三、 Node.js 适用场景
Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。总的来说，Node.js 能几乎实现所有的应用，但我们用不用还需要看使用的场景，比如银行页面这种高并发的可以使用，但是对于一些轻量级应用我们使用 PHP 即可。
##### 3.1 RESTful API
这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。
##### 3.2 统一Web应用的UI层
目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。  
不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。
##### 3.3 大量Ajax请求的应用
例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。　　总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。
